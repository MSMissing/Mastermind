// stack program. by MSMissing on github

// NOTE: STACK OVERFLOWS/UNDERFLOWS WILL FUCK UP YOUR PROGRAM
// Also, this has inline brainfuck in it, so it probably won't be readable.

struct stack255 {
  cell[510] arr;
  cell one;
  cell len;
  cell end;
}

struct stack32 {
  cell[64] arr;
  cell one;
  cell len;
  cell end;
}

// == DOCUMENTATION ==

// struct stack255        -- a stack object you can push to and pop from.
//                           can hold up to 255 values.

// struct stack32         -- smaller stack. holds 32 values.

// push(stack, x)         -- pushes x to the stack

// push_d(stack, x)       -- pushes x to the stack, destroying it in the
//                           process. faster than push

// push_safe(stack, x)    -- pushes x to the stack, and outputs an error if
//                           if it can't. cannot end the program.

// push_d_safe(stack, x) -- same as push_safe, but destructive

// pop(stack, out)       -- pulls the last value from the stack and puts it
//                          into out.

// pop_safe(stack, out)  -- same as pop, but outputs an error if the stack
//                          underflows. cannot end the program.



// REMEMBER TO INITIALIZE YOUR STACKS OR THE CODE WILL LIKELY BE SLOWER
fn init_stack(struct stack255 stack) {
  stack.one = 1;
}

fn init_stack(struct stack32 stack) {
  stack.one = 1;
}

fn move_to_current(cell one) { // move the pointer to the last value pushe
  bf @one {                    // input is stack.one
    [<<]>>>
  }
}
fn move_to_one() { // move pointer to stack.one after calling move_to_current()
  bf {
    <[>>]<<
  }
}

fn push_d(struct stack255 stack, cell in) { // destructive version of push
  stack.one = 1;
  stack.len += 1;
  
  // set usage flag
  bf @stack.one clobbers *stack.arr {
    [<<]+[>>]<<
  }
  
  // drain input to the array item
  while in {
    in -= 1;
    move_to_current(stack.one);
    bf clobbers *stack.arr {+}
    move_to_one();
  }
}

fn push_d(struct stack32 stack, cell in) {
  stack.one = 1;
  stack.len += 1;
  
  // set usage flag
  bf @stack.one clobbers *stack.arr {
    [<<]+[>>]<<
  }
  
  // drain input to the array item
  while in {
    in -= 1;
    move_to_current(stack.one);
    bf clobbers *stack.arr {+}
    move_to_one();
  }
}

fn push(struct stack255 stack, cell x) {
  cell in = x; // copy the input
  push_d(stack, in);
}

fn push(struct stack32 stack, cell x) {
  cell in = x;
  push_d(stack, x);
}

fn push_safe(struct stack255 stack, cell x) {
  if stack.len - 255 {
    push(stack, x);
  } else {
    output "STACK OVERFLOW";
  }
}

fn push_safe(struct stack32 stack, cell x) {
  if stack.len - 32 {
    push(stack, x);
  } else {
    output "STACK OVERFLOW";
  }
}

fn push_d_safe(struct stack255 stack, cell in) {
  if stack.len - 255 {
    push_d(stack, in);
  } else {
    in = 0;
    output "STACK OVERFLOW";
  }
}

fn push_d_safe(struct stack32 stack, cell in) {
  if stack.len - 32 {
    push_d(stack, in);
  } else {
    in = 0;
    output "STACK OVERFLOW";
  }
}

fn pop(struct stack255 stack, cell return) {
  return = 0;
  stack.one = 1;
  stack.len -= 1;
  
  move_to_current(stack.one);
  bf clobbers *stack.arr return {[-}
    move_to_one();
    return += 1;
    move_to_current(stack.one);
  bf {]<->>>}
  move_to_one();
}

fn pop(struct stack32 stack, cell return) {
  return = 0;
  stack.one = 1;
  stack.len -= 1;
  
  move_to_current(stack.one);
  bf clobbers *stack.arr return {[-}
    move_to_one();
    return += 1;
    move_to_current(stack.one);
  bf clobbers *stack.arr {]<->>>}
  move_to_one();
}

fn pop_safe(struct stack255 stack, cell return) {
  if stack.len {
    pop(stack, return);
  } else {
    return = 0;
    output "STACK UNDERFLOW";
  }
}

fn pop_safe(struct stack32 stack, cell return) {
  if stack.len {
    pop(stack, return);
  } else {
    return = 0;
    output "STACK UNDERFLOW";
  }
}







